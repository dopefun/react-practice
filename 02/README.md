# Практическая работа №2: Управление состоянием между компонентами

### Введение

В предыдущей практической работе был рассмотрен фундаментальный хук React — `useState`. Он позволяет компонентам "помнить" информацию, создавая локальное, инкапсулированное состояние. Такое состояние является приватным и полностью контролируется тем компонентом, в котором оно объявлено. Это идеальное решение для управления данными, которые не требуются за пределами одного элемента интерфейса, например, для отслеживания значения в поле ввода или состояния переключателя.

Однако по мере роста сложности приложений возникает новая задача: необходимость синхронизации состояния между несколькими компонентами. Представим ситуацию, когда два или более компонента должны отражать одни и те же изменяющиеся данные. Например, панель с настройками фильтров и список отображаемых элементов — изменение фильтра должно немедленно влиять на список. Или, как в примере, который будет рассмотрен далее, два поля для ввода температуры — одно в градусах Цельсия, другое в Фаренгейтах. При вводе значения в одно поле, второе должно автоматически пересчитываться и обновляться.

Если каждый из этих компонентов будет хранить свое собственное локальное состояние, их синхронизация станет нетривиальной задачей, чреватой ошибками и расхождениями в данных. Компоненты по своей природе изолированы и не имеют прямого доступа к состоянию своих "соседей". Это подводит к ключевому вопросу: как эффективно и предсказуемо управлять общим состоянием в React?

Ответом на этот вопрос является один из центральных архитектурных паттернов React — «**подъём состояния вверх**» (**Lifting State Up**). Эта работа посвящена глубокому изучению данного паттерна, его теоретическому обоснованию и практическому применению.

## Часть 1. Теория: Единый источник правды

### 1.1. Проблема синхронизации и дублирования состояния

Попытка синхронизировать два независимых локальных состояния является антипаттерном в экосистеме React. Когда несколько компонентов дублируют одни и те же данные в своем внутреннем состоянии, возникает ряд фундаментальных проблем:

* **Рассинхронизация данных:** Если пользователь изменяет данные в одном компоненте, необходимо разработать сложный механизм для уведомления другого компонента и принудительного обновления его состояния. Этот механизм усложняет код и часто приводит к ошибкам, когда одно из состояний обновляется некорректно или несвоевременно.
* **Непредсказуемость UI:** React декларирует, что пользовательский интерфейс является функцией от состояния $UI = f(state)$. Если в приложении существует несколько конкурирующих "источников правды" для одних и тех же данных, становится невозможно гарантировать, что UI в любой момент времени будет консистентным и предсказуемым.
* **Нарушение потока данных:** React построен на принципе однонаправленного потока данных (top-down data flow), где состояние "течет" от родительских компонентов к дочерним. Попытки наладить коммуникацию и синхронизацию между компонентами- "соседями" (sibling components) нарушают эту простую и понятную модель, делая отладку и поддержку приложения значительно сложнее.

Вместо того чтобы пытаться синхронизировать несколько копий одного и того же состояния, следует придерживаться принципа, что для любых изменяемых данных в приложении должен существовать единственный "владелец".

---

### 1.2. Решение — «Подъём состояния вверх» (Lifting State Up)

«**Подъём состояния вверх**» — это основной паттерн в React для организации совместного доступа к состоянию и его синхронизации. Суть паттерна заключается в перемещении состояния из дочерних компонентов, которым оно необходимо, в их ближайший общий родительский компонент.

Этот родительский компонент становится «**единым источником правды**» (**Single Source of Truth**). Он единственный "владеет" этим состоянием и несет ответственность за его изменение. Все остальные компоненты, которым необходимы эти данные, получают их от родителя через props и становятся "управляемыми" этим состоянием.

Такой подход дает несколько ключевых преимуществ:
* **Предсказуемость:** Устраняется дублирование и возможная рассинхронизация. Все компоненты всегда отображают актуальные данные из одного источника.
* **Упрощение отладки:** Когда в интерфейсе возникает ошибка, связанная с данными, разработчику не нужно проверять несколько компонентов. Источник проблемы всегда находится в компоненте-владельце состояния. Это значительно сокращает "поверхность" для поиска багов.
* **Централизованное управление:** Логика обновления состояния сосредоточена в одном месте, что делает ее более понятной и легкой для модификации.

Процесс подъёма состояния обычно включает три последовательных шага 5:
1. **Удалить состояние из дочерних компонентов:** Из дочерних компонентов удаляется вызов хука `useState`, который отвечал за локальное хранение общих данных.
2. **Передать данные от общего родителя:** Находится ближайший общий компонент-предок для всех дочерних элементов, которые нужно синхронизировать. Этот родитель начинает передавать необходимые данные своим дочерним компонентам через props. На начальном этапе это могут быть даже статичные, "захардкоженные" значения для проверки связности.
3. **Добавить состояние в родителя:** В родительском компоненте создается состояние с помощью `useState`. Значение этого состояния, а также функции для его изменения, передаются дочерним компонентам через props.

---

### 1.3. Поток данных: «Props вниз, события вверх»

После подъёма состояния устанавливается четкая и строгая модель взаимодействия между родительским и дочерними компонентами, которую часто описывают как "**props down, events up**" (свойства вниз, события вверх).

* **Props Down (Свойства вниз):** Компонент-владелец (родитель) передает текущее значение состояния своим дочерним компонентам через `props`. Дочерние компоненты получают эти данные и используют их исключительно для отображения. Важно помнить, что `props` являются неизменяемыми (read-only) для дочернего компонента.
* **Events Up (События вверх):** Поскольку дочерний компонент не может напрямую изменять полученные `props`, ему нужен способ сообщить родителю о необходимости изменить состояние. Для этого родитель передает дочернему компоненту не только данные, но и функцию-колбэк (например, `onValueChange`). Когда в дочернем компоненте происходит событие (например, пользователь вводит текст в поле), он не меняет свое состояние (у него его больше нет), а вызывает эту полученную по `props` функцию, передавая ей новое значение. Эта функция, определенная в родительском компоненте, содержит логику вызова `setState` и инициирует обновление "единого источника правды".

Этот цикл — передача данных вниз и отправка запросов на изменение вверх — является основой интерактивности в приложениях на React, построенных с использованием паттерна "Lifting State Up".

---

### 1.4. Контролируемые компоненты (Controlled Components)

Понятие «**контролируемых компонентов**» неразрывно связано с процессом подъёма состояния, особенно при работе с элементами форм, такими как `<input>`, `<textarea>` и `<select>`.

**Контролируемый компонент** — это элемент ввода, чье значение полностью контролируется состоянием React, а не его собственным внутренним состоянием в DOM.8 React-состояние становится единственным источником правды для значения этого элемента.

Чтобы сделать элемент формы контролируемым, необходимо выполнить два условия 10:
1. Передать его текущее значение через prop `value` (или `checked` для чекбоксов и радиокнопок), привязав его к переменной состояния React.
2. Передать функцию-обработчик в prop `onChange`, которая будет обновлять состояние в React при каждом взаимодействии пользователя с элементом.

Когда мы поднимаем состояние из компонента с полем ввода в его родителя, этот дочерний компонент автоматически становится контролируемым. Он больше не может самостоятельно управлять своим значением. Вместо этого он полностью зависит от `props`, которые ему передает родитель:

* **Цель:** Синхронизировать два поля ввода.
* **Решение:** Поднять их общее состояние в родительский компонент.
* **Следствие:** Теперь состояние "живет" в родителе. Дочерний компонент-инпут должен как-то отобразить это значение. Он получает его через prop `value`. При каждом рендере React принудительно устанавливает значение инпута равным значению из `props`.
* **Проблема:** Как родителю узнать, что пользователь ввел новые данные, чтобы обновить свое состояние?
* **Решение:** Родитель передает дочернему компоненту функцию-колбэк (например, `onTemperatureChange`) через `props`. Дочерний компонент привязывает эту функцию к своему внутреннему событию `onChange`.
* **Итог:** При вводе текста срабатывает `onChange` инпута, который вызывает `props.onTemperatureChange`, который, в свою очередь, вызывает `setState` в родительском компоненте. Этот замкнутый цикл и есть суть контролируемого компонента. Таким образом, "контролируемость" — это не просто опция, а необходимое техническое следствие применения паттерна "Lifting State Up" для интерактивных элементов.

В следующей таблице представлено сравнение двух подходов к управлению состоянием.

| Характеристика | Локальное состояние ( `useState` в дочернем компоненте) | Поднятое состояние (Lifting State Up) |
| :--- | :--- | :--- |
| **Расположение состояния** | Внутри компонента, который его использует. | В ближайшем общем родительском компоненте. |
| **Источник правды** | Каждый компонент имеет свой собственный. | Один общий "источник правды" для группы компонентов. |
| **Поток данных** | Состояние не покидает компонент. | Данные передаются вниз через `props`, запросы на изменение — вверх через колбэки. |
| **Синхронизация** | Невозможно напрямую синхронизировать с другими компонентами. | Основная цель — синхронизация состояния между компонентами. |
| **Сложность** | Минимальная. Идеально для изолированной логики. | Выше. Требует проброса `props` и функций-обработчиков. |
| **Переиспользуемость** | Компонент более автономен, но менее гибок в контексте. | Дочерние компоненты становятся "глупыми" и более переиспользуемыми, т.к. не содержат логики. |
| **Пример использования** | Состояние открыт/закрыт для модального окна; значение поля ввода в простой форме. | Конвертер валют; фильтры, влияющие на список; аккордеон, где открыта только одна секция. |

---

## Часть 2. Практика: Создание конвертера температур

В этой части будет создан интерактивный калькулятор температуры, который демонстрирует применение паттерна "Lifting State Up" на практике. Калькулятор будет иметь два поля ввода: для градусов Цельсия и Фаренгейта. При изменении значения в одном поле, другое будет автоматически пересчитываться. Также будет выводиться сообщение о том, закипит ли вода при указанной температуре.4

### 2.1. Начальная структура проекта

Для начала необходимо создать три компонента в отдельных файлах:
* **`Calculator.js`**: Родительский компонент, который будет содержать состояние и логику.
* **`TemperatureInput.js`**: Дочерний компонент для поля ввода температуры. Будет использоваться дважды.
* **`BoilingVerdict.js`**: Простой компонент, который будет отображать сообщение о кипении воды.

**Файл: `BoilingVerdict.js` (JavaScript)**
```javascript
import React from 'react';

function BoilingVerdict(props) {
  if (props.celsius >= 100) {
    return <p>Вода закипит.</p>;
  }
  return <p>Вода не закипит.</p>;
}

export default BoilingVerdict;
```

**Файл: `BoilingVerdict.js` (JavaScript)**
```javascript
import React from 'react';
import TemperatureInput from './TemperatureInput';
import BoilingVerdict from './BoilingVerdict';

function Calculator() {
  return (
    <div>
      {/* Здесь будут два TemperatureInput */}
      <BoilingVerdict celsius={0} />
    </div>
  );
}

export default Calculator;
```

---

### 2.2. TemperatureInput с локальным состоянием (демонстрация проблемы)

Сначала реализуем `TemperatureInput` с его собственным, локальным состоянием. Это наглядно продемонстрирует проблему отсутствия синхронизации.

**Файл: `TemperatureInput.js` (с локальным состоянием - JavaScript)**
```javascript
import React, { useState } from 'react';

const scaleNames = {
  c: 'Цельсия',
  f: 'Фаренгейта'
};

function TemperatureInput({ scale }) {
  const [temperature, setTemperature] = useState('');

  const handleChange = (e) => {
    setTemperature(e.target.value);
  };

  return (
    <fieldset>
      <legend>Введите температуру в градусах {scaleNames[scale]}:</legend>
      <input
        value={temperature}
        onChange={handleChange} />
    </fieldset>
  );
}

export default TemperatureInput;
```
Теперь добавим два экземпляра этого компонента в `Calculator`:

**Файл: `Calculator.js` (с несогласованными инпутами - JavaScript)**
```javascript

function Calculator() {
  return (
    <div>
      <TemperatureInput scale="c" />
      <TemperatureInput scale="f" />
      <BoilingVerdict celsius={0} />
    </div>
  );
}

export default Calculator;
```

**Импорт калькулятора в `App.js` (JavaScript)**
```javascript
import React from 'react';
import Calculator from './Calculator';
import './styles.css';

export default function App() {
  return (
    <div className="App">
      <h1>Конвертер Температур</h1>
      <Calculator />
    </div>
  );
}
```

Если запустить это приложение, можно увидеть два поля ввода. Ввод значения в одно из них никак не повлияет на другое. Они полностью независимы, что не соответствует нашей цели.

---

### 2.3. Процесс подъёма состояния (шаг за шагом)

Теперь выполним рефакторинг, следуя шагам, описанным в теоретической части.

**Шаг 1: Рефакторинг TemperatureInput**

Превратим `TemperatureInput` в контролируемый, "глупый" компонент. Он больше не будет хранить свое состояние, а будет получать его из props.
* Удаляем `useState` из `TemperatureInput`.
* Компонент теперь принимает два новых props: `temperature` для значения и `onTemperatureChange` в качестве обработчика.

**Файл: `TemperatureInput.js` (контролируемая версия - JavaScript)**
```javascript
import React from 'react';

const scaleNames = {
  c: 'Цельсия',
  f: 'Фаренгейта'
};

function TemperatureInput({ scale, temperature, onTemperatureChange }) {
  const handleChange = (e) => {
    onTemperatureChange(e.target.value);
  };

  return (
    // Используем div вместо fieldset
    <div className="temperature-input-group"> 
      {/* Используем label вместо legend */}
      <label>Введите температуру в градусах {scaleNames[scale]}:</label>
      <input
        value={temperature}
        onChange={handleChange} />
    </div>
  );
}

export default TemperatureInput;
```

**Шаг 2: Добавление состояния в Calculator**

Теперь `Calculator` станет "источником правды".
* Добавим в `Calculator` состояние с помощью `useState`. Важно отметить, что мы будем хранить только **одно** значение температуры и его шкалу. Второе значение всегда можно вычислить. Хранение вычисляемых данных в состоянии — это антипаттерн, который может привести к рассинхронизации.4

**Файл: `Calculator.js` (добавление состояния - JavaScript)**
```javascript
import React, { useState } from 'react';
import TemperatureInput from './TemperatureInput';
import BoilingVerdict from './BoilingVerdict';

//... (BoilingVerdict остается тем же)

function Calculator() {
  const [temperature, setTemperature] = useState("");
  const [scale, setScale] = useState("c");

  //... (логика и рендер будут здесь)
  return (
    <div>
      {/*... */}
    </div>
  );
}

export default Calculator;
```

**Шаг 3: Связывание родителя и детей**

Создадим в `Calculator` функции-обработчики, которые будут обновлять состояние, и передадим их вместе со значениями в дочерние компоненты.

**Файл: `Calculator.js` (добавление обработчиков - JavaScript)**
```javascript

function Calculator() {
  const [temperature, setTemperature] = useState("");
  const [scale, setScale] = useState("c");

  const handleCelsiusChange = (temperature) => {
    setScale('c');
    setTemperature(temperature);
  };

  const handleFahrenheitChange = (temperature) => {
    setScale('f');
    setTemperature(temperature);
  };

  //... (логика конвертации и рендер будут здесь)
  return (
    <div>
      {/* Пока передаем пустые значения */}
      <TemperatureInput
        scale="c"
        temperature={''}
        onTemperatureChange={handleCelsiusChange}
      />
      <TemperatureInput
        scale="f"
        temperature={''}
        onTemperatureChange={handleFahrenheitChange}
      />
      <BoilingVerdict celsius={0} />
    </div>
  );
}

export default Calculator;
```

---

### 2.4. Реализация логики конвертации

Осталось добавить логику преобразования температур. Создадим две вспомогательные функции для конвертации и используем их в методе render компонента `Calculator`.

**Файл: `Calculator.js` (полная версия - JavaScript)**
```javascript
import React, { useState } from 'react';
import TemperatureInput from './TemperatureInput';
import BoilingVerdict from './BoilingVerdict';

function toCelsius(fahrenheit) {
  return (fahrenheit - 32) * 5 / 9;
}

function toFahrenheit(celsius) {
  return (celsius * 9 / 5) + 32;
}

function tryConvert(temperature, convert) {
  const input = parseFloat(temperature);
  if (Number.isNaN(input)) {
    return '';
  }
  const output = convert(input);
  const rounded = Math.round(output * 1000) / 1000;
  return rounded.toString();
}

function Calculator() {
  const [temperature, setTemperature] = useState('');
  const [scale, setScale] = useState('c');

  const handleCelsiusChange = (temperature) => {
    setScale('c');
    setTemperature(temperature);
  };

  const handleFahrenheitChange = (temperature) => {
    setScale('f');
    setTemperature(temperature);
  };

  const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature;
  const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature;

  return (
    <div>
      <TemperatureInput
        scale="c"
        temperature={celsius}
        onTemperatureChange={handleCelsiusChange}
      />
      <TemperatureInput
        scale="f"
        temperature={fahrenheit}
        onTemperatureChange={handleFahrenheitChange}
      />
      <BoilingVerdict celsius={parseFloat(celsius)} />
    </div>
  );
}

export default Calculator;
```

---

### 2.5. Замените стили в styles.css

Теперь, когда структура стала проще, мы можем написать для нее более предсказуемые стили. Полностью замените содержимое файла `src/styles.css` на этот код:

```css
/* --- Глобальные стили и переменные --- */
:root {
  --primary-color: #007bff;
  --light-gray: #f8f9fa;
  --medium-gray: #e9ecef;
  --dark-gray: #495057;
  --text-color: #212529;
  --white: #ffffff;
  --shadow-color: rgba(0, 0, 0, 0.08);
  --border-radius: 12px;
}

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: var(--light-gray);
  color: var(--text-color);
  display: flex;
  justify-content: center;
  padding-top: 60px;
}

/* --- Основной контейнер приложения --- */
.App {
  width: 100%;
  max-width: 450px;
  text-align: center;
  padding: 20px;
}

.App h1 {
  color: var(--dark-gray);
  font-weight: 600;
  margin-bottom: 40px;
}

/* --- Группа ввода температуры (новый стиль) --- */
.temperature-input-group {
  margin-bottom: 30px;
  text-align: left;
}

.temperature-input-group label {
  display: block;
  margin-bottom: 8px;
  font-size: 1rem;
  font-weight: 500;
  color: var(--dark-gray);
}

/* --- Стили для самого поля ввода --- */
input {
  width: 100%;
  padding: 15px;
  font-size: 1.5rem;
  font-weight: 300;
  color: var(--text-color);
  background-color: var(--white);
  border: 1px solid var(--medium-gray);
  border-radius: var(--border-radius);
  box-sizing: border-box;
  box-shadow: 0 2px 5px var(--shadow-color);
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
}

input:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
}

/* --- Стили для вердикта --- */
p {
  background-color: var(--white);
  padding: 25px;
  margin: 0;
  font-size: 1.2rem;
  font-weight: 500;
  color: var(--primary-color);
  border-radius: var(--border-radius);
  box-shadow: 0 4px 15px var(--shadow-color);
}
```

---

### 2.6. Итоговый код и анализ потока данных

Теперь оба поля ввода полностью синхронизированы. Проследим весь цикл обновления на примере ввода числа "100" в поле Цельсия 6:

1.  Пользователь вводит "100" в первое поле `TemperatureInput` (шкала 'c').
2.  В этом компоненте срабатывает событие `onChange`, которое вызывает функцию `handleChange`.
3.  `handleChange` вызывает `props.onTemperatureChange("100")`.
4.  Этот `prop` является ссылкой на метод `handleCelsiusChange` в компоненте `Calculator`.
5.  `handleCelsiusChange("100")` вызывается в `Calculator`. Он выполняет `setScale('c')` и `setTemperature("100")`.
6.  React обнаруживает изменение состояния и планирует повторный рендер компонента `Calculator`.
7.  `Calculator` рендерится заново. Внутри него вычисляются переменные:
    * `scale` равен 'c', поэтому `celsius` присваивается значение `temperature`, то есть "100".
    * `fahrenheit` вычисляется с помощью `tryConvert("100", toFahrenheit)`, что дает "212".
8.  `Calculator` рендерит два дочерних компонента `TemperatureInput`:
    * Первому передается `temperature={celsius}` (т.е. "100").
    * Второму передается `temperature={fahrenheit}` (т.е. "212").
9.  Оба поля ввода на экране обновляются, отображая "100" и "212" соответственно.
10. Компонент `BoilingVerdict` получает `celsius={100}` и отображает сообщение "Вода закипит."

Этот пример наглядно показывает, что, хотя паттерн "Lifting State Up" требует написания большего количества "шаблонного" кода (проброс `props`, определение колбэков), он обеспечивает абсолютную предсказуемость и централизованное управление состоянием. Этот компромисс является осознанным архитектурным решением, которое упрощает отладку и поддержку сложных приложений.

---

## Часть 3. Задание для самостоятельной работы: Динамический конвертер валют

### 3.1. Постановка задачи

Разработать динамический конвертер валют, который позволяет пользователю выбирать исходную и целевую валюты из выпадающих списков и производить конвертацию в реальном времени.

### 3.2. Требования к реализации

* **Добавить выбор валют:** В родительском компоненте `CurrencyConverter` рядом с каждым полем ввода `CurrencyInput` добавьте HTML-элемент `<select>` (выпадающий список). Каждый список должен содержать как минимум три опции: 'RUB', 'USD', 'EUR'.

* **Поднять состояние выбора:** Состояние того, какая валюта выбрана в каждом из списков, также должно "жить" в родительском компоненте `CurrencyConverter`. Вам понадобятся дополнительные переменные состояния, например:
    ```javascript
    const [currencyFrom, setCurrencyFrom] = useState('RUB');
    const [currencyTo, setCurrencyTo] = useState('USD');
    ```

* **Создать объект курсов:** Вместо одного фиксированного курса, создайте объект для хранения всех обменных курсов относительно одной базовой валюты.
    ```javascript
    const rates = {
      'USD': 1, 
      'RUB': 83,
      'EUR': 0.86
    };
    ```

* **Реализовать универсальную логику конвертации:** Ваша логика пересчета теперь должна быть динамической. Когда пользователь вводит сумму в одно из полей, вам нужно:
    * Взять эту сумму.
    * Перевести ее в базовую валюту (USD).
    * Из базовой валюты перевести в целевую валюту, выбранную во втором списке.

* **Отображать текущий курс:** Добавьте под полями ввода текстовый элемент, который будет показывать текущий обменный курс между выбранными валютами. Например: `1 RUB = 0.011 USD`. Этот элемент тоже должен обновляться при изменении выбора в любом из `<select>`.
