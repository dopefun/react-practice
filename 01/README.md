# Практическая работа №1: Основы React – Компоненты, JSX, Props и State

### Введение

#### Цели и задачи практической работы

Основной целью данной практической работы является формирование фундаментальных теоретических знаний и получение практических навыков для создания интерактивных пользовательских интерфейсов с использованием библиотеки React.

В ходе выполнения работы будут решены следующие ключевые задачи:

* Изучение декларативного подхода и компонентной архитектуры, лежащих в основе React.
* Освоение синтаксиса JSX, его правил и отличий от стандартного HTML.
* Определение и практическое применение функциональных компонентов как основных строительных блоков приложения.
* Использование механизма props для передачи данных между компонентами и создания переиспользуемых UI-элементов.
* Внедрение интерактивности в компоненты с помощью хука `useState` и обработки пользовательских событий.
* Осуществление рендеринга динамических списков на основе коллекций данных.

#### Краткий обзор библиотеки React

**React** представляет собой JavaScript-библиотеку, предназначенную для создания пользовательских интерфейсов (UI). Важно отметить, что React является именно библиотекой, а не полнофункциональным фреймворком.

В основе философии React лежат два ключевых принципа:

* **Декларативность (Declarative):** React позволяет описывать, как должен выглядеть пользовательский интерфейс для любого заданного состояния приложения. При изменении этих данных React самостоятельно и эффективно обновляет только необходимые части DOM, чтобы привести UI в соответствие с новым состоянием.
* **Компонентная основа (Component-Based):** Весь пользовательский интерфейс в React-приложении строится из независимых, инкапсулированных и переиспользуемых частей, называемых компонентами. Сложные интерфейсы создаются путем композиции более простых компонентов.

#### Описание итогового проекта: "Каталог сотрудников"

В рамках данной практической работы будет разработан проект **"Каталог сотрудников"**. Это веб-приложение, представляющее собой страницу со списком карточек сотрудников компании. Пользователь сможет по клику на кнопку отображать или скрывать дополнительную информацию (например, контактный email), при этом состояние каждой карточки будет независимым от остальных.

---

## Часть 1. Теоретические основы

### 1.1. Декларативный подход и компонентная архитектура

При **императивном подходе** разработчик должен писать детальные, пошаговые инструкции для изменения интерфейса. **Декларативный подход** React, напротив, освобождает от этой рутинной работы: разработчик просто описывает, какой UI должен быть отрендерен для определенного набора данных (состояния).

**Компонентная архитектура** представляет UI как иерархию "строительных блоков". Компонент в React – это, по своей сути, JavaScript-функция, которая принимает данные (в виде props) и возвращает описание того, как должен выглядеть соответствующий фрагмент интерфейса (в виде JSX).

### 1.2. Среда разработки: CodeSandbox

Для выполнения данной практической работы используется онлайн-среда разработки **CodeSandbox**.

**Анализ структуры проекта:**

* **`public/index.html`**: Это единственный HTML-файл. Он содержит корневой элемент `<div id="root">`, в который React будет "монтировать" все приложение.
* **`src/index.js`**: Входная точка для JavaScript-кода. Здесь используется `react-dom` для отрисовки корневого компонента `<App />`.
* **`src/App.js`**: Корневой компонент приложения. Вся иерархия компонентов начинается здесь.
* **`src/styles.css`**: Файл для определения глобальных CSS-стилей.

### 1.3. Синтаксис JSX (JavaScript XML)

**JSX** – это синтаксическое расширение для JavaScript, которое позволяет писать HTML-подобную разметку непосредственно в JavaScript-файлах.

**Правила JSX:**

* **Единый корневой элемент:** Функция компонента должна возвращать только один родительский (корневой) элемент. Для возврата нескольких элементов можно использовать `<div>` или сокращенный синтаксис `React.Fragment`: `<>...</>`.
* **Обязательное закрытие тегов:** В JSX абсолютно все теги должны быть закрыты, включая самозакрывающиеся (`<img />`, `<input />`).
* **Атрибуты в `camelCase`:** HTML-атрибуты, состоящие из нескольких слов, записываются в стиле `camelCase` (например, `tabIndex`).
* **`className` вместо `class`:** Для указания CSS-классов используется атрибут `className`, так как `class` является зарезервированным ключевым словом в JavaScript.

**Внедрение JavaScript в JSX:**

Для встраивания JavaScript-выражений (переменной, вызова функции, арифметической операции) прямо в разметку используется синтаксис с фигурными скобками: `{}`.

```javascript
const userName = "Алексей";
const element = <h1>Привет, {userName}!</h1>; // Выведет "Привет, Алексей!"

function calculateYear(age) {
  return new Date().getFullYear() - age;
}
const userAge = 30;
const birthYearElement = <p>Год рождения: {calculateYear(userAge)}</p>;
```
В таблице ниже представлены ключевые синтаксические различия между HTML и JSX.
### Таблица 1: Сравнение синтаксиса JSX и HTML

| Возможность | Синтаксис HTML | Синтаксис JSX | Пояснение |
| :--- | :--- | :--- | :--- |
| CSS-класс | `class="card"` | `className="card"` | [cite_start]`class` является зарезервированным словом в JavaScript. |
| Встроенные стили | `style="color: red;"` | `style={{ color: 'red' }}` | Стили передаются как JavaScript-объект. [cite_start]Имена свойств записываются в `camelCase`. |
| Самозакрывающийся тег | `<br>` | `<br />` | [cite_start]В JSX все теги должны быть явно закрыты. |
| Связывание метки | `for="name"` | `htmlFor="name"` | [cite_start]`for` является зарезервированным словом для циклов в JavaScript. |
| Комментарии | \`\` | `{/* Комментарий */}` | [cite_start]Комментарии в JSX используют синтаксис блочных комментариев JavaScript, обернутый в фигурные скобки. |
| Переменная JavaScript | Н/Д | `<h1>{userName}</h1>` | [cite_start]Фигурные скобки используются для встраивания JavaScript-выражений. |

### 1.4. Функциональные компоненты

В современной разработке на React основным способом создания компонентов являются **функциональные компоненты**. Это обычные JavaScript-функции, которые принимают на вход объект со свойствами (**props**) и возвращают **JSX-разметку**, описывающую, как должен выглядеть UI.

#### Синтаксис и структура

Типичная структура файла компонента выглядит следующим образом:

1.  **Импорт** необходимых зависимостей (как минимум `React`).
2.  **Определение** функции компонента.
3.  **Экспорт** функции по умолчанию, чтобы ее можно было использовать в других частях приложения.

**Пример (JavaScript):**

```javascript
// 1. Импорт
import React from 'react';

// 2. Определение функции
function WelcomeMessage() {
  // 3. Возврат JSX
  return <h1>Добро пожаловать в наше приложение!</h1>;
}

// 4. Экспорт
export default WelcomeMessage;
```

#### Правило именования

Существует **строгое правило**: имена React-компонентов всегда должны начинаться с **заглавной буквы**. Это требование не является просто стилистическим соглашением, а имеет глубокую техническую причину.

**JSX-транспилятор** (например, Babel) использует регистр первой буквы для того, чтобы отличить пользовательские компоненты от нативных HTML-тегов.

* Когда транспилятор встречает тег, начинающийся со **строчной буквы** (например, `<div />`), он преобразует его в вызов `React.createElement("div")`, передавая имя тега в виде строки.
* Однако, если тег начинается с **заглавной буквы** (например, `<WelcomeMessage />`), он будет преобразован в `React.createElement(WelcomeMessage)`, где `WelcomeMessage` – это прямая ссылка на JavaScript-функцию (или класс) компонента.

Таким образом, **капитализация** является фундаментальным синтаксическим контрактом, который позволяет React правильно интерпретировать и рендерить разметку.

## Часть 2. Практическая реализация: Создание приложения "Каталог сотрудников"

В этой части теоретические знания будут применены для пошагового создания приложения "Каталог сотрудников".

---

### 2.1. Создание первого статического компонента: TeamMemberCard

Первым шагом является создание компонента, который будет отвечать за отображение карточки одного сотрудника. На данном этапе компонент будет **статическим**, то есть все данные будут жестко закодированы непосредственно в разметке.

1.  **Создание файла:** В навигаторе файлов **[CodeSandbox](https://codesandbox.io/p/sandbox/react-new)** в директории `src` необходимо создать новый файл с именем `TeamMemberCard.js`.

2.  **Базовая структура:** В созданном файле следует определить базовую структуру функционального компонента.

    **Файл: `src/TeamMemberCard.js` (JavaScript)**

    ```javascript
    import React from 'react';

    function TeamMemberCard() {
      return (
        <div className="card">
          <img 
            src="(https://avatar.iran.liara.run/public/boy/1" 
            alt="Аватар сотрудника"
            className="avatar"
          />
          <h2>Иван Иванов</h2>
          <p>Frontend-разработчик</p>
        </div>
      );
    }

    export default TeamMemberCard;
    ```
    > Здесь используется сервис `avatar.iran.liara.run` для получения случайного изображения-аватара.

3.  **Добавление стилей:** Для визуального оформления карточки необходимо добавить соответствующие стили в файл `src/styles.css`.

    **Файл: `src/styles.css` (CSS)**

    ```css
     body {
      font-family: sans-serif;
      background-color: #f4f4f9;
      padding-top: 40px;
    }
    
    .app-container {
      width: 80%;
      max-width: 1200px;
      margin: 0 auto;
      text-align: center;
    }
    
    .team-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;
      justify-content: center;
    }
    
    .card {
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      padding: 20px;
      text-align: center;
      transition: transform 0.2s;
    }
    
    .card:hover {
      transform: translateY(-5px);
    }
    
    .avatar {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      object-fit: cover;
      margin-bottom: 15px;
    }
    
    .card h2 {
      margin: 10px 0;
      font-size: 1.2em;
    }
    
    .card p {
      color: #666;
      margin: 5px 0;
    }
    
    .card button {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 4px;
      cursor: pointer;
      margin: 5px;
      transition: background-color 0.2s;
    }
    
    .card button:hover {
      background-color: #0056b3;
    }
    
    .status-online {
      color: #28a745;
      font-weight: bold;
    }
    
    .status-offline {
      color: #6c757d;
      font-style: italic;
    }
    ```

4.  **Отображение компонента:** Теперь необходимо импортировать и использовать созданный компонент `TeamMemberCard` в корневом компоненте `App.js`.

    **Файл: `src/App.js` (JavaScript)**

    ```javascript
    import React from 'react';
    import TeamMemberCard from './TeamMemberCard';
    import './styles.css';

    export default function App() {
      return (
        <div className="app-container">
          <h1>Наша команда</h1>
          <div className="team-grid">
            <TeamMemberCard />
          </div>
        </div>
      );
    }
    ```
После сохранения файлов в окне предпросмотра должна появиться одна карточка сотрудника.

<div align="center">
  <img src="images/practice-1-img-1.png" alt="Карточки сотрудника" width="100%" />
</div>

### 2.2. Использование props для передачи данных

Статический компонент непрактичен, так как не может отображать разные данные. Чтобы сделать **TeamMemberCard** переиспользуемым, необходимо использовать **props** (сокращение от "properties"). **Props** – это механизм, позволяющий родительскому компоненту передавать данные дочернему. Важнейшей характеристикой props является их **иммутабельность** (неизменяемость): компонент не имеет права изменять полученные им props.

1.  **Модификация TeamMemberCard:** Компонент **TeamMemberCard** будет изменен так, чтобы он принимал объект **props** в качестве аргумента. Для удобства используется синтаксис деструктуризации, чтобы сразу извлечь необходимые свойства.

    **Файл: `src/TeamMemberCard.js` (JavaScript)**

    ```javascript
    import React from 'react';

    function TeamMemberCard({ avatarUrl, name, position }) {
      return (
        <div className="card">
          <img 
            src={avatarUrl} 
            alt={`Аватар ${name}`} 
            className="avatar"
          />
          <h2>{name}</h2>
          <p>{position}</p>
        </div>
      );
    }

    export default TeamMemberCard;
    ```
Теперь статические данные заменены на переменные, полученные из props.

2.  **Передача данных из App.js:** В компоненте **App** теперь можно вызывать **TeamMemberCard** несколько раз, передавая каждый раз уникальные данные через атрибуты, имена которых соответствуют ожидаемым props.

    **Файл: `src/App.js` (JavaScript)**

    ```javascript
    import React from 'react';
    import TeamMemberCard from './TeamMemberCard';
    import './styles.css';

    export default function App() {
      return (
        <div className="app-container">
          <h1>Наша команда</h1>
          <div className="team-grid">
            <TeamMemberCard 
              avatarUrl="https://avatar.iran.liara.run/public/boy?username=Alex"
              name="Алексей Петров"
              position="Lead Developer"
            />
            <TeamMemberCard 
              avatarUrl="https://avatar.iran.liara.run/public/girl?username=Maria"
              name="Мария Сидорова"
              position="UI/UX Designer"
            />
            <TeamMemberCard 
              avatarUrl="https://avatar.iran.liara.run/public/boy?username=Dmitry"
              name="Дмитрий Волков"
              position="Project Manager"
            />
          </div>
        </div>
      );
    }
    ```
В результате на странице будут отображены три разные карточки сотрудников, что демонстрирует переиспользуемость компонента.

<div align="center">
  <img src="images/practice-1-img-2.png" alt="Три карточки" width="100%" />
</div>

### 2.3. Рендеринг списков из массива данных

Жестко кодировать вызовы компонентов в разметке неудобно, особенно когда данные поступают из внешнего источника (например, API). Более правильный подход – хранить данные в виде массива и динамически генерировать компоненты на его основе.

1.  **Создание источника данных:** В **App.js** будет создан массив объектов, представляющих сотрудников.

    **Файл: `src/App.js` (начало файла - JavaScript)**
    ```javascript
    const teamData = [
      {
        id: 1,
        name: "Мария Иванова",
        position: "Frontend-разработчик",
        avatarUrl: "https://avatar.iran.liara.run/public/girl?username=Maria",
      },
      {
        id: 2,
        name: "Алексей Смирнов",
        position: "Backend-разработчик",
        avatarUrl: "https://avatar.iran.liara.run/public/boy?username=Alex",
      },
      {
        id: 3,
        name: "Ольга Петрова",
        position: "UX/UI Дизайнер",
        avatarUrl: "https://avatar.iran.liara.run/public/girl?username=Olga",
      },
      {
        id: 4,
        name: "Иван Кузнецов",
        position: "Project Manager",
        avatarUrl: "https://avatar.iran.liara.run/public/boy?username=Ivan",
      },
    ];
    ```

2.  **Динамический рендеринг:** Для преобразования этого массива данных в массив React-компонентов используется стандартный метод JavaScript `Array.prototype.map()`.

    **Файл: `src/App.js` (компонент App - JavaScript)**
    ```javascript
    export default function App() {
      return (
        <div className="app-container">
          <h1>Наша команда</h1>
          <div className="team-grid">
            {teamData.map(member => (
              <TeamMemberCard 
                key={member.id}
                avatarUrl={member.avatarUrl}
                name={member.name}
                position={member.position}
              />
            ))}
          </div>
        </div>
      );
    }
    ```

3.  **Атрибут `key`:** При рендеринге списков каждый элемент должен иметь **уникальный атрибут `key`**. Этот атрибут является подсказкой для React. Он помогает "виртуальному DOM" эффективно определять, какие элементы в списке были изменены, добавлены или удалены при обновлении данных. Это позволяет избежать ненужных перерисовок и потенциальных ошибок с состоянием компонентов. В качестве значения для `key` следует использовать стабильный и уникальный идентификатор из данных, например, `id` записи. Использование индекса массива в качестве `key` не рекомендуется, так как порядок элементов может меняться, что приведет к проблемам с производительностью и некорректному поведению UI.

### 2.4. Введение в состояние (State) и хук useState

До сих пор приложение было статичным: оно отображает данные, но не реагирует на действия пользователя. Для создания интерактивности вводится понятие **состояния (state)**. Состояние – это данные, которые принадлежат компоненту и могут изменяться с течением времени (например, в результате клика по кнопке). В отличие от props, которые передаются извне и являются неизменяемыми, state является внутренним и управляемым самим компонентом. Ключевая особенность состояния заключается в том, что любое его изменение автоматически вызывает **повторный рендеринг (re-render)** компонента, обновляя UI в соответствии с новыми данными.

В функциональных компонентах для управления состоянием используются **хуки (Hooks)**. Хук – это специальная функция, которая позволяет "подключиться" к возможностям React, таким как состояние или жизненный цикл, из обычных JavaScript-функций.

Основным хуком для работы с состоянием является `useState`. Его синтаксис выглядит следующим образом:

**Синтаксис `useState` (JavaScript):**
```javascript
const [stateVariable, setStateFunction] = useState(initialValue);
```
Вызов `useState` возвращает массив из двух элементов, которые обычно получают с помощью деструктуризации:

1.  `stateVariable`: Текущее значение переменной состояния. При первом рендере оно будет равно `initialValue`.
2.  `setStateFunction`: Функция, которую необходимо вызывать для обновления значения состояния. Вызов этой функции с новым значением запланирует re-render компонента.

Значение `initialValue` используется только один раз, при самом первом рендере компонента, для установки начального состояния.

### 2.5. Добавление интерактивности в TeamMemberCard

Теперь добавим в карточку сотрудника возможность отображать и скрывать дополнительную информацию (email) по клику.

1.  **Модификация данных:** Сначала необходимо добавить `email` в исходный массив `teamData` в `App.js` и передать его через props.

    **Файл: `src/App.js` (обновленный массив `teamData` - JavaScript)**
    ```javascript
    const teamData = [
      {
        id: 1,
        name: "Мария Иванова",
        position: "Frontend-разработчик",
        avatarUrl: "https://avatar.iran.liara.run/public/girl?username=Maria",
        email: "maria@email.com",
      },
      {
        id: 2,
        name: "Алексей Смирнов",
        position: "Backend-разработчик",
        avatarUrl: "https://avatar.iran.liara.run/public/boy?username=Alex",
        email: "alex@email.com",
      },
      {
        id: 3,
        name: "Ольга Петрова",
        position: "UX/UI Дизайнер",
        avatarUrl: "https://avatar.iran.liara.run/public/girl?username=Olga",
        email: "olga@email.com",
      },
      {
        id: 4,
        name: "Иван Кузнецов",
        position: "Project Manager",
        avatarUrl: "https://avatar.iran.liara.run/public/boy?username=Ivan",
        email: "ivan@email.com",
      },
    ];
    ```
    > Не забудьте добавить `email={member.email}` при вызове `TeamMemberCard` в методе `map`.

2.  **Реализация состояния и логики в TeamMemberCard:**

    **Файл: `src/TeamMemberCard.js` (JavaScript)**
    ```javascript
    import React, { useState } from 'react'; // 1. Импорт useState

    function TeamMemberCard({ avatarUrl, name, position, email }) {
      // 2. Инициализация состояния для управления видимостью
      const [detailsVisible, setDetailsVisible] = useState(false);

      // 3. Функция-обработчик для переключения состояния
      const handleToggleDetails = () => {
        setDetailsVisible(!detailsVisible);
      };

      return (
        <div className="card">
          <img 
            src={avatarUrl} 
            alt={`Аватар ${name}`} 
            className="avatar"
          />
          <h2>{name}</h2>
          <p>{position}</p>

          {/* 4. Условный рендеринг блока с деталями */}
          {detailsVisible && (
            <div className="details">
              <p>Email: {email}</p>
            </div>
          )}

          {/* 5. Кнопка с привязкой обработчика onClick */}
          <button onClick={handleToggleDetails}>
            {detailsVisible ? 'Скрыть' : 'Подробнее'}
          </button>
        </div>
      );
    }

    export default TeamMemberCard;
    ```

В результате на странице будут отображены четыре разные карточки сотрудников с возможностью отобразить почту.


<div align="center">
  <img src="images/practice-1-img-3.png" alt="Карточки с почтой" width="100%" />
</div>


**Разбор реализации:**
1.  `useState` импортируется из библиотеки `react`.
2.  Внутри компонента вызывается `useState(false)`. Это создает переменную состояния `detailsVisible` с начальным значением `false` и функцию `setDetailsVisible` для ее изменения.
3.  Создается функция `handleToggleDetails`, которая при вызове обновляет состояние на противоположное (`true` -> `false`, `false` -> `true`).
4.  Используется **условный рендеринг** с помощью логического оператора `&&`. Блок `div` с `email` будет отрендерен только в том случае, если `detailsVisible` имеет значение `true`.
5.  Кнопке передается атрибут `onClick`, который в React именуется в `camelCase`. В качестве значения передается ссылка на функцию-обработчик `handleToggleDetails`.

Важно понимать, что состояние, созданное с помощью `useState`, является **локальным и инкапсулированным** внутри каждого конкретного экземпляра компонента. Когда React рендерит список карточек с помощью `.map()`, он создает независимый экземпляр `TeamMemberCard` для каждого сотрудника. Каждый из этих экземпляров получает свой собственный, изолированный "слот памяти" для состояния `detailsVisible`. Поэтому, когда происходит клик по кнопке "Подробнее" на одной карточке, вызывается `setDetailsVisible` только для этого экземпляра. Это изменяет только его локальное состояние и вызывает re-render только этой конкретной карточки, не затрагивая остальные. Это наглядная демонстрация мощи компонентной инкапсуляции, которая позволяет создавать сложные и независимые UI-элементы.

## Часть 3. Итоговое задание для самостоятельной работы

### 3.1. Постановка задачи

Модифицировать существующее приложение "Каталог сотрудников" для добавления функциональности отслеживания и изменения **рабочего статуса** каждого сотрудника (находится ли он на рабочем месте).

### 3.2. Требования к реализации

1.  **Модификация данных:** В исходный массив `teamData` в файле `App.js` для каждого объекта сотрудника необходимо добавить новое свойство **`onSite`** с булевым значением (`true` или `false`). Начальные значения можно распределить произвольно.
2.  **Передача данных:** Новое свойство `onSite` должно быть передано в компонент `TeamMemberCard` через props.
3.  **Отображение статуса:** Внутри компонента `TeamMemberCard` необходимо отобразить текстовый индикатор статуса. Если `onSite` равно `true`, должен выводиться текст **"На месте"**. Если `false` – **"Отсутствует"**. Для визуального выделения статуса следует использовать условные CSS-классы. Например, можно добавить `<p className={onSite ? 'status-online' : 'status-offline'}>....` Соответствующие стили для этих классов (`.status-online` и `.status-offline`), изменяющие цвет текста (например, зеленый и серый), нужно добавить в `src/styles.css`.
4.  **Добавление интерактивности:** В карточку `TeamMemberCard` необходимо добавить новую кнопку с текстом **"Изменить статус"**. По клику на эту кнопку статус сотрудника должен изменяться на противоположный (с "На месте" на "Отсутствует" и наоборот).
5.  **Ограничение:** Для реализации данной функциональности разрешается использовать только те концепции и инструменты, которые были рассмотрены в данной практической работе, а именно: **props** и хук **useState**. Вся логика изменения статуса должна быть инкапсулирована внутри компонента `TeamMemberCard`.

### 3.3. Ожидаемый результат

* При первоначальной загрузке страницы каждая карточка сотрудника отображает его начальный рабочий статус с соответствующим цветом текста.
* Клик по кнопке **"Изменить статус"** на одной из карточек изменяет текстовый статус и его цвет **только для этой конкретной карточки**, не затрагивая состояние соседних карточек.
* Состояние рабочего статуса (`onSite`) должно быть независимым от состояния видимости деталей (`detailsVisible`). Изменение одного состояния не должно влиять на другое.

---

### Источники

1.  React – A JavaScript library for building user interfaces, дата последнего обращения: октября 31, 2025, https://legacy.reactjs.org/
2.  facebook/react: The library for web and native user interfaces. - GitHub, дата последнего обращения: октября 31, 2025, https://github.com/facebook/react
3.  React, дата последнего обращения: октября 31, 2025, https://react.dev/
4.  React documentation - DevDocs, дата последнего обращения: октября 31, 2025, https://devdocs.io/react/
5.  Your First Component – React, дата последнего обращения: октября 31, 2025, https://react.dev/learn/your-first-component
6.  Components and Props - React, дата последнего обращения: октября 31, 2025, https://legacy.reactjs.org/docs/components-and-props.html
7.  Writing Markup with JSX – React, дата последнего обращения: октября 31, 2025, https://react.dev/learn/writing-markup-with-jsx
8.  Thinking in React, дата последнего обращения: октября 31, 2025, https://react.dev/learn/thinking-in-react
9.  Setting up React Project on Online Editor CodeSandbox! | by Meghana Vadlapally | Medium, дата последнего обращения: октября 31, 2025, https://meghanareddy500.medium.com/setting-up-react-project-on-online-editor-codesandbox-2bc9ca45ed1
10. React - Codesandbox, дата последнего обращения: октября 31, 2025, https://codesandbox.io/s/react-new
11. Introducing JSX - React, дата последнего обращения: октября 31, 2025, https://legacy.reactjs.org/docs/introducing-jsx.html
12. Quick Start - React, дата последнего обращения: октября 31, 2025, https://react.dev/learn
13. Documentation - JSX - TypeScript, дата последнего обращения: октября 31, 2025, https://www.typescriptlang.org/docs/handbook/jsx.html
14. Avatar Placeholder | Get free random avatars, дата последнего обращения: октября 31, 2025, https://avatar-placeholder.iran.liara.run/
15. mhshariatipour1378/Avatars-Placeholder: Use this free API service to get and download random avatars based on username , gender and job for user profile pictures. Perfect for your avatar image needs in projects and prototypes. - GitHub, дата последнего обращения: октября 31, 2025, https://github.com/mhshariatipour1378/Avatars-Placeholder
16. Passing Props to a Component – React, дата последнего обращения: октября 31, 2025, https://react.dev/learn/passing-props-to-a-component
17. React Fundamentals - React Native, дата последнего обращения: октября 31, 2025, https://reactnative.dev/docs/intro-react
18. Using the State Hook - React, дата последнего обращения: октября 31, 2025, https://legacy.reactjs.org/docs/hooks-state.html
19. useState – React, дата последнего обращения: октября 31, 2025, https://react.dev/reference/react/useState
