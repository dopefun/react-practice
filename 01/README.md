# Практическая работа №1: Основы React – Компоненты, JSX, Props и State

### Введение

#### Цели и задачи практической работы

Основной целью данной практической работы является формирование фундаментальных теоретических знаний и получение практических навыков для создания интерактивных пользовательских интерфейсов с использованием библиотеки React.

В ходе выполнения работы будут решены следующие ключевые задачи:

* Изучение декларативного подхода и компонентной архитектуры, лежащих в основе React.
* Освоение синтаксиса JSX, его правил и отличий от стандартного HTML.
* Определение и практическое применение функциональных компонентов как основных строительных блоков приложения.
* Использование механизма props для передачи данных между компонентами и создания переиспользуемых UI-элементов.
* Внедрение интерактивности в компоненты с помощью хука `useState` и обработки пользовательских событий.
* Осуществление рендеринга динамических списков на основе коллекций данных.

#### Краткий обзор библиотеки React

**React** представляет собой JavaScript-библиотеку, предназначенную для создания пользовательских интерфейсов (UI). Важно отметить, что React является именно библиотекой, а не полнофункциональным фреймворком.

В основе философии React лежат два ключевых принципа:

* **Декларативность (Declarative):** React позволяет описывать, как должен выглядеть пользовательский интерфейс для любого заданного состояния приложения. При изменении этих данных React самостоятельно и эффективно обновляет только необходимые части DOM, чтобы привести UI в соответствие с новым состоянием.
* **Компонентная основа (Component-Based):** Весь пользовательский интерфейс в React-приложении строится из независимых, инкапсулированных и переиспользуемых частей, называемых компонентами. Сложные интерфейсы создаются путем композиции более простых компонентов.

#### Описание итогового проекта: "Каталог сотрудников"

В рамках данной практической работы будет разработан проект **"Каталог сотрудников"**. Это веб-приложение, представляющее собой страницу со списком карточек сотрудников компании. Пользователь сможет по клику на кнопку отображать или скрывать дополнительную информацию (например, контактный email), при этом состояние каждой карточки будет независимым от остальных.

---

## Часть 1. Теоретические основы

### 1.1. Декларативный подход и компонентная архитектура

При **императивном подходе** разработчик должен писать детальные, пошаговые инструкции для изменения интерфейса. **Декларативный подход** React, напротив, освобождает от этой рутинной работы: разработчик просто описывает, какой UI должен быть отрендерен для определенного набора данных (состояния).

**Компонентная архитектура** представляет UI как иерархию "строительных блоков". Компонент в React – это, по своей сути, JavaScript-функция, которая принимает данные (в виде props) и возвращает описание того, как должен выглядеть соответствующий фрагмент интерфейса (в виде JSX).

### 1.2. Среда разработки: CodeSandbox

Для выполнения данной практической работы используется онлайн-среда разработки **CodeSandbox**.

**Анализ структуры проекта:**

* **`public/index.html`**: Это единственный HTML-файл. Он содержит корневой элемент `<div id="root">`, в который React будет "монтировать" все приложение.
* **`src/index.js`**: Входная точка для JavaScript-кода. Здесь используется `react-dom` для отрисовки корневого компонента `<App />`.
* **`src/App.js`**: Корневой компонент приложения. Вся иерархия компонентов начинается здесь.
* **`src/styles.css`**: Файл для определения глобальных CSS-стилей.

### 1.3. Синтаксис JSX (JavaScript XML)

**JSX** – это синтаксическое расширение для JavaScript, которое позволяет писать HTML-подобную разметку непосредственно в JavaScript-файлах.

**Правила JSX:**

* **Единый корневой элемент:** Функция компонента должна возвращать только один родительский (корневой) элемент. Для возврата нескольких элементов можно использовать `<div>` или сокращенный синтаксис `React.Fragment`: `<>...</>`.
* **Обязательное закрытие тегов:** В JSX абсолютно все теги должны быть закрыты, включая самозакрывающиеся (`<img />`, `<input />`).
* **Атрибуты в `camelCase`:** HTML-атрибуты, состоящие из нескольких слов, записываются в стиле `camelCase` (например, `tabIndex`).
* **`className` вместо `class`:** Для указания CSS-классов используется атрибут `className`, так как `class` является зарезервированным ключевым словом в JavaScript.

**Внедрение JavaScript в JSX:**

Для встраивания JavaScript-выражений (переменной, вызова функции, арифметической операции) прямо в разметку используется синтаксис с фигурными скобками: `{}`.

```jsx
const userName = "Алексей";
const element = <h1>Привет, {userName}!</h1>; // Выведет "Привет, Алексей!"

function calculateYear(age) {
  return new Date().getFullYear() - age;
}
const userAge = 30;
const birthYearElement = <p>Год рождения: {calculateYear(userAge)}</p>;
```
В таблице ниже представлены ключевые синтаксические различия между HTML и JSX.
### Таблица 1: Сравнение синтаксиса JSX и HTML

| Возможность | Синтаксис HTML | Синтаксис JSX | Пояснение |
| :--- | :--- | :--- | :--- |
| CSS-класс | `class="card"` | `className="card"` | `class` является зарезервированным словом в JavaScript. |
| Встроенные стили | `style="color: red;"` | `style={{ color: 'red' }}` | Стили передаются как JavaScript-объект. Имена свойств записываются в `camelCase`. |
| Самозакрывающийся тег | `<br>` | `<br />` | В JSX все теги должны быть явно закрыты. |
| Связывание метки | `for="name"` | `htmlFor="name"` | `for` является зарезервированным словом для циклов в JavaScript. |
| Комментарии | \`\` | `{/* Комментарий */}` | Комментарии в JSX используют синтаксис блочных комментариев JavaScript, обернутый в фигурные скобки. |
| Переменная JavaScript | Н/Д | `<h1>{userName}</h1>` | Фигурные скобки используются для встраивания JavaScript-выражений. |

### 1.4. Функциональные компоненты

В современной разработке на React основным способом создания компонентов являются **функциональные компоненты**. Это обычные JavaScript-функции, которые принимают на вход объект со свойствами (**props**) и возвращают **JSX-разметку**, описывающую, как должен выглядеть UI.

#### Синтаксис и структура

Типичная структура файла компонента выглядит следующим образом:

1.  **Импорт** необходимых зависимостей (как минимум `React`).
2.  **Определение** функции компонента.
3.  **Экспорт** функции по умолчанию, чтобы ее можно было использовать в других частях приложения.

**Пример (JavaScript):**

```jsx
// 1. Импорт
import React from 'react';

// 2. Определение функции
function WelcomeMessage() {
  // 3. Возврат JSX
  return <h1>Добро пожаловать в наше приложение!</h1>;
}

// 4. Экспорт
export default WelcomeMessage;
```

#### Правило именования

Существует **строгое правило**: имена React-компонентов всегда должны начинаться с **заглавной буквы**. Это требование не является просто стилистическим соглашением, а имеет глубокую техническую причину.

**JSX-транспилятор** (например, Babel) использует регистр первой буквы для того, чтобы отличить пользовательские компоненты от нативных HTML-тегов.

* Когда транспилятор встречает тег, начинающийся со **строчной буквы** (например, `<div />`), он преобразует его в вызов `React.createElement("div")`, передавая имя тега в виде строки.
* Однако, если тег начинается с **заглавной буквы** (например, `<WelcomeMessage />`), он будет преобразован в `React.createElement(WelcomeMessage)`, где `WelcomeMessage` – это прямая ссылка на JavaScript-функцию (или класс) компонента.

Таким образом, **капитализация** является фундаментальным синтаксическим контрактом, который позволяет React правильно интерпретировать и рендерить разметку.

## Часть 2. Практическая реализация: Создание приложения "Каталог сотрудников"

В этой части теоретические знания будут применены для пошагового создания приложения "Каталог сотрудников".

---

### 2.1. Создание первого статического компонента: TeamMemberCard

Первым шагом является создание компонента, который будет отвечать за отображение карточки одного сотрудника. На данном этапе компонент будет **статическим**, то есть все данные будут жестко закодированы непосредственно в разметке.

1.  **Создание файла:** В навигаторе файлов **[CodeSandbox](https://codesandbox.io/p/sandbox/react-new)** в директории `src` необходимо создать новый файл с именем `TeamMemberCard.js`.

2.  **Базовая структура:** В созданном файле следует определить базовую структуру функционального компонента.

    **Файл: `src/TeamMemberCard.js` (JavaScript)**

    ```jsx
    import React from 'react';

    function TeamMemberCard() {
      return (
        <div className="card">
          <img 
            src="(https://avatar.iran.liara.run/public/boy/1" 
            alt="Аватар сотрудника"
            className="avatar"
          />
          <h2>Иван Иванов</h2>
          <p>Frontend-разработчик</p>
        </div>
      );
    }

    export default TeamMemberCard;
    ```
    > Здесь используется сервис `avatar.iran.liara.run` для получения случайного изображения-аватара.

3.  **Добавление стилей:** Для визуального оформления карточки необходимо добавить соответствующие стили в файл `src/styles.css`.

    **Файл: `src/styles.css` (CSS)**

    ```css
     body {
      font-family: sans-serif;
      background-color: #f4f4f9;
      padding-top: 40px;
    }
    
    .app-container {
      width: 80%;
      max-width: 1200px;
      margin: 0 auto;
      text-align: center;
    }
    
    .team-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;
      justify-content: center;
    }
    
    .card {
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      padding: 20px;
      text-align: center;
      transition: transform 0.2s;
    }
    
    .card:hover {
      transform: translateY(-5px);
    }
    
    .avatar {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      object-fit: cover;
      margin-bottom: 15px;
    }
    
    .card h2 {
      margin: 10px 0;
      font-size: 1.2em;
    }
    
    .card p {
      color: #666;
      margin: 5px 0;
    }
    
    .card button {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 4px;
      cursor: pointer;
      margin: 5px;
      transition: background-color 0.2s;
    }
    
    .card button:hover {
      background-color: #0056b3;
    }
    
    .status-online {
      color: #28a745;
      font-weight: bold;
    }
    
    .status-offline {
      color: #6c757d;
      font-style: italic;
    }
    ```

4.  **Отображение компонента:** Теперь необходимо импортировать и использовать созданный компонент `TeamMemberCard` в корневом компоненте `App.js`.

    **Файл: `src/App.js` (JavaScript)**

    ```jsx
    import React from 'react';
    import TeamMemberCard from './TeamMemberCard';
    import './styles.css';

    export default function App() {
      return (
        <div className="app-container">
          <h1>Наша команда</h1>
          <div className="team-grid">
            <TeamMemberCard />
          </div>
        </div>
      );
    }
    ```
После сохранения файлов в окне предпросмотра должна появиться одна карточка сотрудника.

<div align="center">
  <img src="images/practice-1-img-1.png" alt="Карточки сотрудника" width="100%" />
</div>

### 2.2. Использование props для передачи данных

Статический компонент непрактичен, так как не может отображать разные данные. Чтобы сделать **TeamMemberCard** переиспользуемым, необходимо использовать **props** (сокращение от "properties"). **Props** – это механизм, позволяющий родительскому компоненту передавать данные дочернему. Важнейшей характеристикой props является их **иммутабельность** (неизменяемость): компонент не имеет права изменять полученные им props.

1.  **Модификация TeamMemberCard:** Компонент **TeamMemberCard** будет изменен так, чтобы он принимал объект **props** в качестве аргумента. Для удобства используется синтаксис деструктуризации, чтобы сразу извлечь необходимые свойства.

    **Файл: `src/TeamMemberCard.js` (JavaScript)**

    ```jsx
    import React from 'react';

    function TeamMemberCard({ avatarUrl, name, position }) {
      return (
        <div className="card">
          <img 
            src={avatarUrl} 
            alt={`Аватар ${name}`} 
            className="avatar"
          />
          <h2>{name}</h2>
          <p>{position}</p>
        </div>
      );
    }

    export default TeamMemberCard;
    ```
Теперь статические данные заменены на переменные, полученные из props.

2.  **Передача данных из App.js:** В компоненте **App** теперь можно вызывать **TeamMemberCard** несколько раз, передавая каждый раз уникальные данные через атрибуты, имена которых соответствуют ожидаемым props.

    **Файл: `src/App.js` (JavaScript)**

    ```jsx
    import React from 'react';
    import TeamMemberCard from './TeamMemberCard';
    import './styles.css';

    export default function App() {
      return (
        <div className="app-container">
          <h1>Наша команда</h1>
          <div className="team-grid">
            <TeamMemberCard 
              avatarUrl="https://avatar.iran.liara.run/public/boy?username=Alex"
              name="Алексей Петров"
              position="Lead Developer"
            />
            <TeamMemberCard 
              avatarUrl="https://avatar.iran.liara.run/public/girl?username=Maria"
              name="Мария Сидорова"
              position="UI/UX Designer"
            />
            <TeamMemberCard 
              avatarUrl="https://avatar.iran.liara.run/public/boy?username=Dmitry"
              name="Дмитрий Волков"
              position="Project Manager"
            />
          </div>
        </div>
      );
    }
    ```
В результате на странице будут отображены три разные карточки сотрудников, что демонстрирует переиспользуемость компонента.

<div align="center">
  <img src="images/practice-1-img-2.png" alt="Три карточки" width="100%" />
</div>

### 2.3. Рендеринг списков из массива данных

Жестко кодировать вызовы компонентов в разметке неудобно, особенно когда данные поступают из внешнего источника (например, API). Более правильный подход – хранить данные в виде массива и динамически генерировать компоненты на его основе.

1.  **Создание источника данных:** В **App.js** будет создан массив объектов, представляющих сотрудников.

    **Файл: `src/App.js` (начало файла - JavaScript)**
    ```jsx
    const teamData = [
      {
        id: 1,
        name: "Мария Иванова",
        position: "Frontend-разработчик",
        avatarUrl: "https://avatar.iran.liara.run/public/girl?username=Maria",
      },
      {
        id: 2,
        name: "Алексей Смирнов",
        position: "Backend-разработчик",
        avatarUrl: "https://avatar.iran.liara.run/public/boy?username=Alex",
      },
      {
        id: 3,
        name: "Ольга Петрова",
        position: "UX/UI Дизайнер",
        avatarUrl: "https://avatar.iran.liara.run/public/girl?username=Olga",
      },
      {
        id: 4,
        name: "Иван Кузнецов",
        position: "Project Manager",
        avatarUrl: "https://avatar.iran.liara.run/public/boy?username=Ivan",
      },
    ];
    ```

2.  **Динамический рендеринг:** Для преобразования этого массива данных в массив React-компонентов используется стандартный метод JavaScript `Array.prototype.map()`.

    **Файл: `src/App.js` (компонент App - JavaScript)**
    ```jsx
    export default function App() {
      return (
        <div className="app-container">
          <h1>Наша команда</h1>
          <div className="team-grid">
            {teamData.map(member => (
              <TeamMemberCard 
                key={member.id}
                avatarUrl={member.avatarUrl}
                name={member.name}
                position={member.position}
              />
            ))}
          </div>
        </div>
      );
    }
    ```

3.  **Атрибут `key`:** При рендеринге списков каждый элемент должен иметь **уникальный атрибут `key`**. Этот атрибут является подсказкой для React. Он помогает "виртуальному DOM" эффективно определять, какие элементы в списке были изменены, добавлены или удалены при обновлении данных. Это позволяет избежать ненужных перерисовок и потенциальных ошибок с состоянием компонентов. В качестве значения для `key` следует использовать стабильный и уникальный идентификатор из данных, например, `id` записи. Использование индекса массива в качестве `key` не рекомендуется, так как порядок элементов может меняться, что приведет к проблемам с производительностью и некорректному поведению UI.

### 2.4. Введение в состояние (State) и хук useState

До сих пор приложение было статичным: оно отображает данные, но не реагирует на действия пользователя. Для создания интерактивности вводится понятие **состояния (state)**. Состояние – это данные, которые принадлежат компоненту и могут изменяться с течением времени (например, в результате клика по кнопке). В отличие от props, которые передаются извне и являются неизменяемыми, state является внутренним и управляемым самим компонентом. Ключевая особенность состояния заключается в том, что любое его изменение автоматически вызывает **повторный рендеринг (re-render)** компонента, обновляя UI в соответствии с новыми данными.

В функциональных компонентах для управления состоянием используются **хуки (Hooks)**. Хук – это специальная функция, которая позволяет "подключиться" к возможностям React, таким как состояние или жизненный цикл, из обычных JavaScript-функций.

Основным хуком для работы с состоянием является `useState`. Его синтаксис выглядит следующим образом:

**Синтаксис `useState` (JavaScript):**
```jsx
const [stateVariable, setStateFunction] = useState(initialValue);
```
Вызов `useState` возвращает массив из двух элементов, которые обычно получают с помощью деструктуризации:

1.  `stateVariable`: Текущее значение переменной состояния. При первом рендере оно будет равно `initialValue`.
2.  `setStateFunction`: Функция, которую необходимо вызывать для обновления значения состояния. Вызов этой функции с новым значением запланирует re-render компонента.

Значение `initialValue` используется только один раз, при самом первом рендере компонента, для установки начального состояния.

### 2.5. Добавление интерактивности в TeamMemberCard

Теперь добавим в карточку сотрудника возможность отображать и скрывать дополнительную информацию (email) по клику.

1.  **Модификация данных:** Сначала необходимо добавить `email` в исходный массив `teamData` в `App.js` и передать его через props.

    **Файл: `src/App.js` (обновленный массив `teamData` - JavaScript)**
    ```jsx
    const teamData = [
      {
        id: 1,
        name: "Мария Иванова",
        position: "Frontend-разработчик",
        avatarUrl: "https://avatar.iran.liara.run/public/girl?username=Maria",
        email: "maria@email.com",
      },
      {
        id: 2,
        name: "Алексей Смирнов",
        position: "Backend-разработчик",
        avatarUrl: "https://avatar.iran.liara.run/public/boy?username=Alex",
        email: "alex@email.com",
      },
      {
        id: 3,
        name: "Ольга Петрова",
        position: "UX/UI Дизайнер",
        avatarUrl: "https://avatar.iran.liara.run/public/girl?username=Olga",
        email: "olga@email.com",
      },
      {
        id: 4,
        name: "Иван Кузнецов",
        position: "Project Manager",
        avatarUrl: "https://avatar.iran.liara.run/public/boy?username=Ivan",
        email: "ivan@email.com",
      },
    ];
    ```
    > Не забудьте добавить `email={member.email}` при вызове `TeamMemberCard` в методе `map`.

2.  **Реализация состояния и логики в TeamMemberCard:**

    **Файл: `src/TeamMemberCard.js` (JavaScript)**
    ```jsx
    import React, { useState } from 'react'; // 1. Импорт useState

    function TeamMemberCard({ avatarUrl, name, position, email }) {
      // 2. Инициализация состояния для управления видимостью
      const [detailsVisible, setDetailsVisible] = useState(false);

      // 3. Функция-обработчик для переключения состояния
      const handleToggleDetails = () => {
        setDetailsVisible(!detailsVisible);
      };

      return (
        <div className="card">
          <img 
            src={avatarUrl} 
            alt={`Аватар ${name}`} 
            className="avatar"
          />
          <h2>{name}</h2>
          <p>{position}</p>

          {/* 4. Условный рендеринг блока с деталями */}
          {detailsVisible && (
            <div className="details">
              <p>Email: {email}</p>
            </div>
          )}

          {/* 5. Кнопка с привязкой обработчика onClick */}
          <button onClick={handleToggleDetails}>
            {detailsVisible ? 'Скрыть' : 'Подробнее'}
          </button>
        </div>
      );
    }

    export default TeamMemberCard;
    ```

В результате на странице будут отображены четыре разные карточки сотрудников с возможностью отобразить почту.


<div align="center">
  <img src="images/practice-1-img-3.png" alt="..." width="100%" />
</div>


**Разбор реализации:**
1.  `useState` импортируется из библиотеки `react`.
2.  Внутри компонента вызывается `useState(false)`. Это создает переменную состояния `detailsVisible` с начальным значением `false` и функцию `setDetailsVisible` для ее изменения.
3.  Создается функция `handleToggleDetails`, которая при вызове обновляет состояние на противоположное (`true` -> `false`, `false` -> `true`).
4.  Используется **условный рендеринг** с помощью логического оператора `&&`. Блок `div` с `email` будет отрендерен только в том случае, если `detailsVisible` имеет значение `true`.
5.  Кнопке передается атрибут `onClick`, который в React именуется в `camelCase`. В качестве значения передается ссылка на функцию-обработчик `handleToggleDetails`.

Важно понимать, что состояние, созданное с помощью `useState`, является **локальным и инкапсулированным** внутри каждого конкретного экземпляра компонента. Когда React рендерит список карточек с помощью `.map()`, он создает независимый экземпляр `TeamMemberCard` для каждого сотрудника. Каждый из этих экземпляров получает свой собственный, изолированный "слот памяти" для состояния `detailsVisible`. Поэтому, когда происходит клик по кнопке "Подробнее" на одной карточке, вызывается `setDetailsVisible` только для этого экземпляра. Это изменяет только его локальное состояние и вызывает re-render только этой конкретной карточки, не затрагивая остальные. Это наглядная демонстрация мощи компонентной инкапсуляции, которая позволяет создавать сложные и независимые UI-элементы.

## Часть 3. Итоговое задание для самостоятельной работы

### 3.1. Постановка задачи

Модифицировать существующее приложение "Каталог сотрудников" для добавления функциональности отслеживания и изменения **рабочего статуса** каждого сотрудника.

### 3.2. Требования к реализации

1.  **Модификация данных:** В исходный массив `teamData` в файле `App.js` для каждого объекта сотрудника необходимо добавить новое свойство **`onSite`** с булевым значением (`true` или `false`). Начальные значения можно распределить произвольно.
2.  **Передача данных:** Новое свойство `onSite` должно быть передано в компонент `TeamMemberCard` через props.
3.  **Отображение статуса:** Внутри компонента `TeamMemberCard` необходимо отобразить текстовый индикатор статуса. Если `onSite` равно `true`, должен выводиться текст **"На месте"**. Если `false` – **"Отсутствует"**.
4.  **Добавление интерактивности:** В карточку `TeamMemberCard` необходимо добавить новую кнопку с текстом **"Изменить статус"**. По клику на эту кнопку статус сотрудника должен изменяться на противоположный (с "На месте" на "Отсутствует" и наоборот).
5.  **Ограничение:** Для реализации данной функциональности разрешается использовать только те концепции и инструменты, которые были рассмотрены в данной практической работе, а именно: **props** и хук **useState**. Вся логика изменения статуса должна быть инкапсулирована внутри компонента `TeamMemberCard`.
