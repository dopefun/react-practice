# Практическая работа №3: Побочные эффекты и загрузка данных – хук useEffect

### Введение

Реальные веб-приложения редко существуют в вакууме; они должны взаимодействовать с внешним миром – получать данные с серверов, подписываться на события браузера или интегрироваться со сторонними библиотеками. Эта практическая работа посвящена освоению механизма, который позволяет компонентам React безопасно и эффективно выполнять такие взаимодействия.

Если `useState` дает компонентам внутреннюю память, то хук `useEffect` предоставляет им возможность взаимодействовать с окружением за пределами React. Он является фундаментальным инструментом для управления так называемыми "побочными эффектами" (side effects).

---

### Цели и задачи практической работы

Основной целью данной работы является освоение концепции побочных эффектов и получение практических навыков их управления с помощью хука `useEffect` для создания динамических, управляемых данными приложений.

В ходе выполнения работы будут решены следующие ключевые задачи:

* Изучение концепции "побочных эффектов" (side effects) и их роли в жизненном цикле компонента.
* Освоение синтаксиса и семантики хука `useEffect` для декларативного управления этими эффектами.
* Формирование навыков контроля частоты выполнения эффектов с помощью массива зависимостей.
* Реализация одного из самых распространенных побочных эффектов: асинхронной загрузки данных с удаленного сервера (API).
* Внедрение паттерна управления асинхронными состояниями (загрузка, успех, ошибка) для создания отзывчивого и понятного пользовательского интерфейса

---

### Краткий обзор хука useEffect

Хук `useEffect` – это основной инструмент в функциональных компонентах React для выполнения побочных эффектов. **Побочный эффект** – это любая операция, которая взаимодействует с внешним миром, то есть находится за пределами чистого процесса рендеринга компонента. `useEffect` можно рассматривать как специальный "шлюз" или "аварийный люк" из декларативного мира React в императивный мир браузерных API, сетевых запросов и сторонних библиотек.

Концептуально `useEffect` объединяет в себе функциональность нескольких методов жизненного цикла из старого подхода с классовыми компонентами, таких как `componentDidMount`, `componentDidUpdate` и `componentWillUnmount`, но предоставляет более гибкий и единый API для управления всеми видами побочных эффектов.

### Описание итогового проекта: "Динамический каталог сотрудников"

В рамках данной практической работы проект "Каталог сотрудников" будет существенно доработан. Вместо использования статичного, жестко закодированного массива данных, приложение будет загружать информацию о сотрудниках из реального публичного REST API.

Это изменение вносит в проект сложности, характерные для реальной разработки: данные не появляются мгновенно. Приложение должно научиться корректно обрабатывать задержку, отображая пользователю индикатор загрузки. Кроме того, оно должно быть устойчивым к возможным сетевым сбоям и ошибкам, информируя пользователя о проблеме. Для этих целей будет использоваться `JSONPlaceholder` – бесплатный и надежный сервис для получения тестовых JSON-данных, в частности, его эндпоинт `/users`.

---

## Часть 1. Теоретические основы

### 1.1. Понятие "побочных эффектов" (Side Effects) в React

Центральная идея React заключается в том, что пользовательский интерфейс является функцией от состояния приложения $UI = f(props, state)$. Процесс рендеринга компонента должен быть "чистой" операцией: при одинаковых входных данных (`props` и `state`) он всегда должен возвращать один и тот же результат (JSX-разметку), не вызывая при этом никаких наблюдаемых изменений за пределами своей области видимости.

Однако приложениям необходимо взаимодействовать с внешним миром. Любая такая операция, выходящая за рамки чистого рендеринга, называется **побочным эффектом (side effect)**.

К наиболее распространенным примерам побочных эффектов относятся:

* **Запросы к API (Data fetching):** Получение данных с сервера или отправка данных на сервер.
* **Подписки (Subscriptions):** Установка слушателей событий (`window.addEventListener`), подключение к WebSocket или другим источникам данных в реальном времени.
* **Прямое манипулирование DOM:** Изменение элементов DOM, которые не управляются React напрямую, например, изменение заголовка документа (`document.title`) или управление фокусом.
* **Таймеры:** Использование функций `setTimeout` и `setInterval` для выполнения отложенных или периодических задач.
* **Логирование:** Отправка данных для аналитики или отладки на внешние сервисы.

Размещение побочных эффектов непосредственно в теле функционального компонента (во время фазы рендеринга) является серьезной ошибкой. Это нарушает принцип чистоты рендера и приводит к непредсказуемому поведению и трудноуловимым багам.

Например, если инициировать загрузку данных и последующее обновление состояния прямо во время рендеринга, это вызовет повторный рендер, который снова инициирует загрузку данных, создавая бесконечный цикл запросов и обновлений.

`useEffect` решает эту проблему, предоставляя специальное место для кода с побочными эффектами, который гарантированно выполняется **после** того, как React завершил все вычисления, обновил DOM и отрисовал изменения на экране. Это отделяет нестабильные, асинхронные операции от основного, предсказуемого потока рендеринга.

---

### 1.2. Хук useEffect: Синтаксис и принципы работы

Хук `useEffect` принимает два аргумента: **функцию с логикой эффекта** и, опционально, **массив зависимостей**.

**Синтаксис `useEffect` (JavaScript):**
```javascript
useEffect(setup, dependencies?);
```
* **`setup` (функция эффекта):** Это функция, которая содержит сам код побочного эффекта (например, `fetch` запрос). React выполняет эту функцию асинхронно **после** того, как компонент был отрендерен и браузер обновил экран. Такой подход гарантирует, что даже длительные операции не будут блокировать отрисовку интерфейса, делая приложение более отзывчивым.

* **`dependencies` (массив зависимостей):** Необязательный второй аргумент, который является ключевым инструментом для управления жизненным циклом эффекта. Он определяет, как часто `setup`-функция будет выполняться.

### Функция "очистки" (Cleanup Function)

Часто побочные эффекты создают ресурсы, которые необходимо освободить, когда компонент исчезает с экрана (unmount) или когда эффект собирается выполниться заново. Примеры таких ресурсов – активные подписки на события, таймеры или открытые WebSocket-соединения. Если не проводить "очистку", это приведет к **утечкам памяти** и непредсказуемому поведению.

Для решения этой задачи `useEffect` использует элегантный механизм: если `setup`-функция возвращает другую функцию, React будет выполнять эту возвращенную функцию (функцию очистки) в двух случаях:

* Перед тем как компонент будет удален из DOM.
* Перед каждым повторным запуском эффекта (если он запускается несколько раз).

* **Пример с таймером (JavaScript):**
```javascript
useEffect(() => {
  const timerId = setTimeout(() => {
    console.log('Таймер сработал!');
  }, 3000);

  // Функция очистки
  return () => {
    console.log('Очистка таймера...');
    clearTimeout(timerId);
  };
},); // Пустой массив означает, что эффект и очистка сработают один раз
```

Такая архитектура является значительным улучшением по сравнению с классовыми компонентами, где логика создания ресурса (например, в `componentDidMount`) и его очистки (в `componentWillUnmount`) была разделена по разным методам. `useEffect` позволяет размещать связанный код вместе, что делает его более читаемым и снижает вероятность ошибок.

---

### 1.3. Управление жизненным циклом: Массив зависимостей

Массив зависимостей – это самый важный инструмент для тонкой настройки поведения `useEffect`. Он позволяет точно указать React, при каких условиях следует перезапускать эффект. Существует три основных сценария его использования.

#### Сценарий 1: Массив не предоставлен (`useEffect(effect)`)

* **Поведение:** Эффект будет запускаться **после каждого рендера** компонента без исключения.
* **Применение:** Этот вариант подходит для эффектов, которые должны синхронизироваться с любыми изменениями в компоненте. Классический пример – обновление заголовка страницы (`document.title`) на основе значения счетчика, который может меняться при каждом рендере.

Для наглядности и быстрого запоминания, различия в поведении можно свести в таблицу.

> **Предостережение:** Использование этого паттерна для асинхронных операций, изменяющих состояние (например, загрузка данных), практически всегда приводит к **бесконечному циклу запросов** и является распространенной ошибкой новичков.

#### Сценарий 2: Пустой массив (`useEffect(effect, [])`)

* **Поведение:** Эффект будет запущен **только один раз**, сразу после самого первого рендера компонента. Функция очистки, если она есть, будет вызвана один раз, когда компонент будет удален из DOM.
* **Применение:** Это идеальный паттерн для однократных инициализационных задач: загрузка начальных данных для страницы, установка глобальных слушателей событий (например, `scroll` или `resize` на объекте `window`), инициализация сторонних библиотек. Этот сценарий является прямым аналогом метода `componentDidMount` в классовых компонентах.

#### Сценарий 3: Массив со значениями (`useEffect(effect, [dep1, dep2])`)

* **Поведение:** Эффект будет запущен один раз после первого рендера, а затем будет **повторно запускаться** каждый раз, когда **изменится хотя бы одно из значений**, перечисленных в массиве зависимостей. React сравнивает значения из предыдущего и текущего рендера, используя алгоритм `Object.is`.
* **Применение:** Этот сценарий используется, когда эффект зависит от конкретных `props` или переменных `state`. Например, если компонент отображает информацию о пользователе и получает `userId` через `props`, эффект для загрузки данных должен перезапускаться каждый раз, когда `userId` меняется: `useEffect(() => { fetchUserData(userId); }, [userId]);`.

Для наглядности и быстрого запоминания, различия в поведении можно свести в таблицу.

### Таблица 2: Сравнительный анализ поведения массива зависимостей useEffect

| Синтаксис | Когда запускается эффект? | Аналог в классовых компонентах | Типичный сценарий использования |
| :--- | :--- | :--- | :--- |
| `useEffect(effect)` | После **каждого** рендера | `componentDidMount` + `componentDidUpdate` | Обновление DOM на основе любого изменения (например, `document.title`) |
| `useEffect(effect, [])` | **Только один раз**, после первого рендера | `componentDidMount` | Однократная загрузка данных, инициализация подписок |
| `useEffect(effect, [dep1, dep2])` | После первого рендера и **при изменении** `dep1` или `dep2` | `componentDidMount` + `componentDidUpdate` с проверкой `if (prevProps.dep1 !== this.props.dep1)` | Повторная загрузка данных при изменении ID, обновление на основе конкретных props |

----

### 1.4. Паттерны асинхронных операций: Загрузка, Данные, Ошибка

Любая асинхронная операция, такая как сетевой запрос, по своей природе непредсказуема. Она занимает время и может завершиться либо успехом, либо неудачей. Для создания качественного пользовательского опыта (UX) недостаточно просто отобразить данные после их загрузки. Необходимо информировать пользователя о текущем состоянии процесса.

Для управления этим процессом в React-компонентах широко используется паттерн, основанный на трех переменных состояния:

* **Состояние данных (`data`):** Хранит успешно загруженные данные. Его начальное значение обычно `null` или пустой массив `[]`, в зависимости от ожидаемого типа данных.
* **Состояние загрузки (`isLoading`):** Булевый флаг, который равен `true`, пока запрос выполняется, и `false` после его завершения. Начальное значение, как правило, `true`, поскольку загрузка часто начинается сразу после монтирования компонента.
* **Состояние ошибки (`error`):** Хранит объект ошибки, если запрос завершился неудачей. В противном случае его значение равно `null`. Начальное значение – `null`.

**Концептуальный пример инициализации состояний (JavaScript):**
```javascript
import { useState } from 'react';

function DataFetchingComponent() {
  const [data, setData] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  //... здесь будет логика useEffect для загрузки данных...

  //... здесь будет условный рендеринг на основе этих состояний...
}
```

Использование этих трех "флагов" позволяет компоненту рендерить различный UI для каждого из возможных состояний: показывать спиннер или скелетон во время загрузки, отображать сообщение об ошибке в случае сбоя и, наконец, рендерить основной контент при успешном получении данных.

---

## Часть 2. Практическая реализация: Динамический "Каталог сотрудников"

В этой части теоретические знания будут применены для преобразования статического приложения "Каталог сотрудников" в динамическое, загружающее данные из сети.

### 2.1. Подготовка к работе с API: Рефакторинг состояния в App.js

Первым шагом является подготовка корневого компонента `App` к работе с асинхронными данными. Необходимо удалить статичный массив `teamData` и заменить его на три переменных состояния, описанных в теоретической части.

1.  Откройте файл **`src/App.js`** в CodeSandbox.
2.  Импортируйте хуки `useState` и `useEffect` из библиотеки `react`.
3.  Удалите или закомментируйте константу `teamData`.
4.  Внутри компонента `App` инициализируйте три новых состояния: `team`, `isLoading` и `error`.

**Файл: `src/App.js` (начальная настройка - JavaScript)**
```javascript
import React, { useState, useEffect } from 'react';
import TeamMemberCard from './TeamMemberCard';
import './styles.css';

export default function App() {
  const = useState();
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  //... остальная логика будет добавлена здесь...

  return (
    <div className="app-container">
      <h1>Наша команда</h1>
      <div className="team-grid">
        {/*... логика рендеринга будет изменена... */}
      </div>
    </div>
  );
}
```

Также надо настроить файл  `src/TeamMemberCard`

```javascript
import React, { useState } from 'react';

function TeamMemberCard({ avatarUrl, name, position, email }) {
  // Локальное состояние для управления видимостью деталей
  const [detailsVisible, setDetailsVisible] = useState(false);

  // Функция-обработчик для переключения состояния
  const handleToggleDetails = () => {
    setDetailsVisible(!detailsVisible);
  };

  return (
    <div className="card">
      <img 
        src={avatarUrl} 
        alt={`Аватар ${name}`} 
        className="avatar"
      />
      <h2>{name}</h2>
      <p>{position}</p>

      {/* Условный рендеринг блока с деталями */}
      {detailsVisible && (
        <div className="details">
          <p>Email: {email}</p>
        </div>
      )}

      {/* Кнопка с привязкой обработчика onClick */}
      <button onClick={handleToggleDetails}>
        {detailsVisible? 'Скрыть' : 'Подробнее'}
      </button>
    </div>
  );
}

export default TeamMemberCard;
```

По желанию можно настроить стили `src/TeamMemberCard`

```javascript
:root {
  --primary-color: #007bff;
  --primary-hover: #0056b3;
  --background-color: #f4f7f6;
  --card-background: #ffffff;
  --text-color: #333;
  --text-secondary: #6c757d;
  --shadow-color: rgba(0, 0, 0, 0.1);
  --border-color: #e9ecef;
  --border-radius: 12px;
}

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  background-color: var(--background-color);
  color: var(--text-color);
  padding: 40px 20px;
}

.app-container {
  max-width: 1200px;
  margin: 0 auto;
  text-align: center;
}

.app-container h1 {
  font-size: 2.5rem;
  font-weight: 600;
  margin-bottom: 40px;
  color: var(--text-color);
}

.team-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 30px;
}

.card {
  background-color: var(--card-background);
  border-radius: var(--border-radius);
  box-shadow: 0 4px 15px var(--shadow-color);
  padding: 25px;
  text-align: center;
  transition: transform 0.3s ease, box-shadow 0.3s ease;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.card:hover {
  transform: translateY(-8px);
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.12);
}

.avatar {
  width: 120px;
  height: 120px;
  border-radius: 50%;
  object-fit: cover;
  margin-bottom: 20px;
  border: 4px solid var(--border-color);
}

.card h2 {
  margin: 10px 0 5px;
  font-size: 1.4em;
  font-weight: 600;
}

.card p {
  color: var(--text-secondary);
  margin: 0 0 15px;
  font-size: 1em;
}

.card button {
  background-color: var(--primary-color);
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 0.9rem;
  font-weight: 500;
  margin-top: 10px;
  transition: background-color 0.2s ease;
}

.card button:hover {
  background-color: var(--primary-hover);
}

.details {
  margin-top: 15px;
  padding: 10px;
  background-color: var(--background-color);
  border-radius: 8px;
  width: 100%;
}

.details p {
  margin: 0;
  font-size: 0.9em;
  color: var(--text-color);
}

.posts-container {
  width: 100%;
  margin-top: 20px;
  text-align: left;
}

.posts-container ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  max-height: 200px;
  overflow-y: auto;
}

.posts-container li {
  padding: 10px;
  border-bottom: 1px solid var(--border-color);
  font-size: 0.9rem;
}

.posts-container li:last-child {
  border-bottom: none;
}

.loading-text,.error-text {
  color: var(--text-secondary);
  font-style: italic;
  margin-top: 15px;
}
```

---

### 2.2. Реализация загрузки данных с помощью useEffect и fetch

Теперь необходимо добавить логику для выполнения сетевого запроса при монтировании компонента. Для этого используется хук `useEffect` с пустым массивом зависимостей. Запрос будет отправлен на эндпоинт `https://jsonplaceholder.typicode.com/users`.

* В компоненте `App` добавьте хук `useEffect`.
* Внутри `useEffect` используйте стандартный браузерный `fetch` API для получения данных.
* Обработайте асинхронный ответ с помощью `async/await` внутри `try/catch/finally` для управления состояниями.

**Файл: `src/App.js` (с логикой загрузки - JavaScript)**
```javascript
import React, { useState, useEffect } from 'react';
import TeamMemberCard from './TeamMemberCard';
import './styles.css';

export default function App() {
  const [team, setTeam] = useState([]); // Инициализируем пустым массивом
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchTeamData = async () => {
      try {
        const response = await fetch('[https://jsonplaceholder.typicode.com/users](https://jsonplaceholder.typicode.com/users)');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        setTeam(data);
      } catch (e) {
        setError(e);
      } finally {
        setIsLoading(false);
      }
    };

    fetchTeamData();
  }, []); // Пустой массив зависимостей гарантирует вызов только один раз

  //... остальная логика...
}
```

**Разбор реализации:**

* `useEffect` с `[]` (пустым массивом) гарантирует, что функция `fetchTeamData` будет вызвана только **один раз** после первого рендера.
* Блок `try` содержит "счастливый путь": запрос, проверка статуса ответа (`!response.ok`), парсинг JSON и обновление состояния `team`.
* Блок `catch` срабатывает, если на любом из этапов в `try` произошла ошибка (сетевая проблема, ошибка сервера). Он сохраняет объект ошибки в состояние `error`.
* Блок `finally` выполняется в любом случае – и при успехе, и при ошибке. Его задача – установить `isLoading` в `false`, сигнализируя о завершении процесса загрузки.

---

### 2.3. Условный рендеринг интерфейса

Теперь, когда компонент управляет состояниями загрузки и ошибки, необходимо отразить это в пользовательском интерфейсе. JSX-разметка внутри `return` будет изменена для отображения соответствующего контента в зависимости от текущего состояния.

**Файл: `src/App.js` (с условным рендерингом - JavaScript)**
```javascript
//... импорты и логика useEffect...

export default function App() {
  //... состояния и useEffect...

  if (isLoading) {
    return (
      <div className="app-container">
        <h1>Загрузка сотрудников...</h1>
      </div>
    );
  }

  if (error) {
    return (
      <div className="app-container">
        <h1>Ошибка при загрузке данных: {error.message}</h1>
      </div>
    );
  }

  return (
    <div className="app-container">
      <h1>Наша команда</h1>
      <div className="team-grid">
        {team.map(member => (
          <TeamMemberCard
            key={member.id}
            //... props будут добавлены на следующем шаге...
          />
        ))}
      </div>
    </div>
  );
}
```

Этот подход обеспечивает надежный UX: пользователь всегда видит актуальный статус приложения. Сначала он увидит сообщение о загрузке, затем – либо сообщение об ошибке, либо готовый список сотрудников.

### 2.4. Адаптация компонента TeamMemberCard

Данные, полученные от JSONPlaceholder API, имеют другую структуру, нежели статический массив. Необходимо адаптировать вызов компонента `TeamMemberCard` внутри метода `.map()`, чтобы передавать ему правильные props.

Структура объекта пользователя от API выглядит примерно так:

```json
{
  "id": 1,
  "name": "Leanne Graham",
  "username": "Bret",
  "email": "Sincere@april.biz",
  //... другие поля
}
```

* Проанализируйте структуру и сопоставьте ее с `props`, которые ожидает `TeamMemberCard`: `key`, `avatarUrl`, `name`, `position`, `email`.
* Обновите вызов `TeamMemberCard` в файле **`src/App.js`**.

**Файл: `src/App.js` (финальная версия - JavaScript)**
```javascript
//... импорты, состояния и useEffect...

export default function App() {
  //... состояния и useEffect...

  if (isLoading) {
    return <div className="app-container"><h1>Загрузка сотрудников...</h1></div>;
  }

  if (error) {
    return <div className="app-container"><h1>Ошибка: {error.message}</h1></div>;
  }

  return (
    <div className="app-container">
      <h1>Наша команда</h1>
      <div className="team-grid">
        {team.map(member => (
          <TeamMemberCard 
            key={member.id}
            avatarUrl={`https://avatar.iran.liara.run/public/boy?username=${member.username}`}
            name={member.name}
            position={member.company.name} // Используем название компании в качестве должности
            email={member.email}
          />
        ))}
      </div>
    </div>
  );
}
```

> **Примечание:** В качестве `position` было решено использовать поле `company.name` из ответа API. Для `avatarUrl` используется сервис аватаров, которому передается `username` пользователя для генерации уникального изображения. Не забудьте также передать `id` из API в компонент `TeamMemberCard` в качестве `key`, что критически важно для производительности React при рендеринге списков.

После этих изменений приложение будет полностью функциональным: при загрузке оно покажет индикатор, затем выполнит запрос к API и отобразит динамически полученный список сотрудников.

<div align="center">
  <img src="/03/images/practice-3-img-1.png" alt="Загрузка данных со стороннеего ресурса" width="100%" />
</div>

---

## Часть 3. Итоговое задание для самостоятельной работы

### 3.1. Постановка задачи

Модифицировать приложение "Каталог сотрудников" для добавления новой функциональности: загрузки и отображения списка постов, написанных конкретным сотрудником. Эта загрузка должна происходить по клику на новую кнопку в карточке сотрудника.

### 3.2. Требования к реализации

* **Передача `id` сотрудника:** Убедитесь, что `id` сотрудника из API передается в компонент `TeamMemberCard` в качестве `prop` (не путать с `key`). Например: `id={member.id}`.
* **Добавление состояния в `TeamMemberCard`:** Внутри компонента `TeamMemberCard` необходимо создать свой собственный, локальный набор состояний для управления загрузкой постов. Потребуются три переменные состояния:
    * `posts` (начальное значение `[]`)
    * `isPostsLoading` (начальное значение `false`)
    * `postsError` (начальное значение `null`)
* **Добавление кнопки:** В JSX-разметку `TeamMemberCard` добавьте новую кнопку с текстом "Показать посты".
* **Создание обработчика клика:** Создайте асинхронную функцию-обработчик (например, `handleFetchPosts`), которая будет вызываться при клике на новую кнопку.
* **Реализация загрузки постов:**
    * Внутри обработчика `handleFetchPosts` сначала установите `isPostsLoading` в `true` и сбросьте `postsError` в `null`.
    * Используйте `fetch` для выполнения GET-запроса к API. JSONPlaceholder предоставляет специальный эндпоинт для получения постов конкретного пользователя: `https://jsonplaceholder.typicode.com/posts?userId=ID`, где `ID` – это `id` сотрудника, полученный через `props`.
    * Обработайте ответ: в случае успеха обновите состояние `posts`, в случае ошибки – `postsError`.
    * В блоке `finally` установите `isPostsLoading` обратно в `false`.
* **Условный рендеринг постов:** Ниже кнопки "Показать посты" в `TeamMemberCard` добавьте логику для условного рендеринга:
    * Если `isPostsLoading` равно `true`, отобразите текст "Загрузка постов...".
    * Если `postsError` не `null`, отобразите сообщение об ошибке.
    * Если посты успешно загружены (`posts.length > 0`), отобразите их в виде простого списка `<ul>`, используя метод `.map()` для итерации по массиву `posts`. Каждый элемент списка должен содержать заголовок поста (`post.title`).

### 3.3. Ожидаемый результат

* При первоначальной загрузке страницы отображается список сотрудников, как и ранее.
* Каждая карточка сотрудника содержит дополнительную кнопку "Показать посты".
* При клике на эту кнопку на одной конкретной карточке:
    * Внутри этой карточки появляется индикатор загрузки.
    * Выполняется сетевой запрос для получения постов **только этого** сотрудника.
    * После завершения загрузки под кнопкой отображается либо список заголовков его постов, либо сообщение об ошибке.
* Действия на одной карточке (загрузка постов, отображение ошибки) **никак не влияют** на состояние других карточек в списке. Это демонстрирует инкапсуляцию состояния и логики внутри каждого экземпляра компонента.

Выполнение этого задания закрепит понимание разницы между загрузкой данных при монтировании компонента (`useEffect`) и загрузкой данных по требованию в ответ на действия пользователя (обработчик событий).
